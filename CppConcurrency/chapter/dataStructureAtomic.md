# 无锁数据结构

> [!note|style:flat]
> 无锁数据结构，能抄尽量抄，实现太复杂。

# 基本定义

## 阻塞与非阻塞

**阻塞：** 使用互斥量、条件变量、`std::future` 来同步数据，线程会处于阻塞态，不会抢占CPU并等待资源达成。
- 互斥量，当没有抢到锁的线程会被阻塞
- 条件量调用`wait()`会等待被唤醒
- future 则会等待结果返回。

**非阻塞：** 线程一直处于运行态，并抢占CPU

## 非阻塞数据结构

非阻塞数据结构分为三个等级，依次递增：
- 无障碍 (obstruction-free)：如果其他线程都暂停了，任何一个给定的线程都会在有限步数内完成操作
- 无锁 (lock-free)：如果多线程在同一个数据结构上操作，其中一个将在有限步数内完成操作
- 无等待 (wait-free)：如果多线程在同一个数据结构上操作，每个线程都会在有限步数内完成操作

## 无锁数据结构

**无锁数据结构的性质：**
- 无锁数据结构必须允许多线程并发访问，但它们不能做相同操作，比如一个无锁 queue 允许一个线程 push、另一个线程 pop，但不允许两个线程同时 push。
- 如果一个访问无锁数据结构的线程被中途挂起，其他线程必须能完成操作而不需要等待挂起的线程，即**无条件量机制**，例如使用pop具有阻塞等待机制的 queue 时，一个线程 push，另一个线程 pop，当 queue 为空时，push 线程挂起，pop 线程则会阻塞等待 push 线程添加内容。

**优点：**
- 实现最大化并发访问，不需要阻塞
- 鲁棒性强，如果线程在持有锁时死掉就会导致数据结构被永久破坏，而对无锁数据结构来说，除了死掉的线程里的数据，其他的数据都不会丢失，因为就没有锁要释放

**缺点：**
- 可能造成更大开销。无锁结构的原子操作可能比非原子操作慢得多，并且原子操作还可能不少。
- 硬件必须访问同一个原子变量以在线程间同步数据

# 无锁线程安全栈


