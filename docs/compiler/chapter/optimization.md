# 代码优化




# 概念

## 中间语言

**中间语言`intermediate code`** : 介于源码于编译目标直接的临时文件，例如 `.i`、`.o`、`.obj`等编译过程中的临时文件
- 比源码的细节多：高级源码不涉及寄存器信息，这是中间语言就可以展开寄存器，便于代码优化
- 比目标的细节少：中间文件不完全是汇编指令，这样便于跨平台移植

编译器在编译过程中可能有很多类型的中间代码，但是后文只讨论一类 「高阶汇编语言`high level assembly`」
- 可操作无限多个寄存器
- 编写规则类似汇编
- 所使用的命令是汇编命令的二次封装，更易用一些

高阶汇编的命令形式如下
- `x = y op z`
- `x = op y`

高级语言的复杂表达式通过引入临时变量可以分解为上述形式，例如 `x + y * z` 可以分解为两次高阶汇编指令的运算
- `t1 = y * z`
- `t2 = x + t1`

将源码转换为高阶汇编与生成汇编的方式类似，使用 `igen(e,t)` 函数描述
- `e` : 待转换的表达式
- `t` : 用于表达式运算的寄存器

![alt|c,40](../../image/compiler/igen_add.png)


中间语言的文法表达

![alt|c,70](../../image/compiler/intermediateRepresentation.png)

> [!note]
> 执行代码优化是在代码生成环节之前，代码优化一般发生在「中间语言」环节
> - 抽象语法树`AST` : 层级太高，无法涉及代码生成细节
> - 汇编代码 ：代码优化操作空间最大，但是汇编指令与机器平台强相关，无法统一优化
> - 中间语言（高阶汇编语言）： 能牵扯到代码生成细节，且与机器平台无关，特别适合进行代码优化

## 术语

**基本块`basic block`** : 高阶汇编的最长指令序列。CPU 运行基本块无需跳转到其他位置，必须从第一条指令开始，一直运行到最后一条指令退出
  - 序列中没有 `label` 定义，除了第一条指令
  - 序列中没有 `jump` 定义， 除了最后一条指令

> [!note]
> 基本块可视为一个内部无函数调用的函数，给输入就能得到输出，因此，编译器只要保证给定输入能得到基本块对应的正确输出就行，内部实现逻辑就可以随便改。

**控制流图 `control flow graph`** : 基本块执行的图表示形式
- 节点： 基本块
- 边方向：基本块的执行流程，例如 `A -> B` 表示执行完基本块 `A` 后，会紧接着执行基本块 `B`

![alt|c,50](../../image/compiler/controlFlowGraph_example.png)

## 优化目标

代码优化通常会对某一项或多项指标进行优化
- 执行时间
- 代码大小
- 网络数据包大小
- 内存占用
- ...

代码优化的方式有
- 局部优化 `local optimization` : 优化单个基本块内部的代码
- 全局优化 `global optimization` : 对构成函数体的控制流图进行优化，**针对的是一个函数**
- 过程间优化 `inter-procedural optimization` : 对一个函数集合进行优化

> [!note]
> 代码优化最重要的前提条件：**对于同一初始条件，保证优化后的目标执行结果与源码描述的结果一致**

# 局部优化


## 代数运算简化

- 删除多余操作：下面几行代码删掉对计算无任何影响

```cool
x := x + 0
x := x * 1
```

- 运算简化

```cool
x := x * 0      ->      x := 0
y := y**2       ->      y := y * y
x := x * 8      ->      x := x << 3
```

## 常量折叠


**常量折叠 `constant fold`** : 对于输入均是常量的表达式，可以直接在编译阶段得到结果

```cool
# 编译时直接计算加法
x := 3 + 4      ->      x := 7

# 该指令被直接删除，因为 2 < 0 永远不可能成立
if 2 < 0 jump L
```

> [!note]
> 常量折叠在交叉编译中可能会出现问题，例如浮点运算在不同架构的 CPU 上处理方案不一致，会导致同一表达式的运算结果在编译器常量折叠与真实机器运算上不一致


## 删除冗余

开发时可能会搞出一些冗余代码，且这些代码永远不会执行，因此，将这些冗余代码在编译时进行删除，不仅能减少目标文件大小，还能提高代码的紧凑度


## 单一赋值

```cool
x := z + y      ->      b := z + y
a := x          ->      a := b
x := 2 * x      ->      x := 2 * b
```

**单一赋值 `static single assignment`** :  使用寄存器 `b` 将代码改写成对每一个变量均只赋值一次，可以简化代码优化。

- 子表达式消除 `common subexpression elimination` : 当两个赋值语句一样时，可以删除多余的运算

    ```cool
    x := y + z      ->      x := y + z
    w := y + z      ->      w := x 
    ```

- 复制传播 `copy propagation` : 当出现 `w := x` 时，后续均使用 `x` 代替 `w`

    ```cool
    x := y + z      ->      x := y + z
    w := z          ->      w := z
    a := y + w      ->      a := y + z  # 这条指令又与 x := y + z 一致，因此还能优化
                    ->      a := x
    ```
- 未引用变量 `dead code` :  在基本块中出现 `w := rhs` ，但是 `w` 未被使用，此时 `w` 被称之为 `dead code` ，可以直接删除

    ```cool
    x := y + z      ->      x := y + z      ->      x := y + z
    w := y + z      ->      w := x 
    x := x * y      ->      a := x * y      ->      a := x * y
    ```